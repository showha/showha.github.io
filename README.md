## 这是我的个人博客网站
### 基础目录
- showha.github.io
  - src
    - AboutMe.html
    - article.html
    - contact.html
    - Experience.html
    - InFuture.html
    - branch.css
    - main.css
    
  - 第二次结队作业
    - main.js
    - page.css
    - page1.html
    - page2-1.html
    - page2-2.html
    - page2-3.html
    - psc(1).jpg
    - test1.py

    - 说明：
      - 想要完整的体验，需要现在本地运行test1.py，然后再打开page1.html，这样才能正常使用页面功能。（PS.当然，如果你是秦始皇，想要在服务器上使用，记得将前端JS：main.js里将http://localhost:5000/ 统一修改成你服务器的IP地址与应用端口）
      - 页面介绍：首页有**开始**与**游戏规则**两个按钮，点击开始按钮后，将会跳转到page2-1.html页面，该页面有**难度一**与**难度二**两个按钮，分别代表一个数组与九个数组这两个功能，点击上述两个任意按钮后，将会跳转到page2-2.html页面，该页面有**生成**、**验证**和**答案**三个按钮。点击其中一个，将会有相应的功能。至于具体怎么实现，您可以亲身探索，我就不剧透了（xixi~）
      - 具体功能实现：前端JS维护三个全局变量，分别是**sudokuBoard**、**sudoku_slove**与**length**。sudokuBoard是一个二维数组，用于存储数独题目，sudoku_slove是一个二维数组，用于存储数独题目的答案，length是一个整数，用于存储数独题目的长度。当点击**生成**按钮时，前端JS将会向后端发送一个Get请求，后端将会返回两个二维数组，一个是待解数独数组，一个是已解数独数组，前端JS将会将两个二维数组分别赋值给sudokuBoard与sudoku_slove，然后将该二维数组的值填入表格中。当点击**验证**按钮时，前端JS将会向后端发送一个Post请求，请求内容为sudokuBoard数组，后端将会返回一个或多个布尔值，前端JS将会根据该布尔值弹出相应的提示框。当点击**答案**按钮时，前端JS将会使用sudoku_slove数组填充表格。至于web传输内容是一个数组抑或是多个数组，则由全局变量length决定，当length为1时，传输的是一个数组，当length为9时，传输的是九个数组。
  - 第二次作业
  
    - Bard.py
  
    - 说明：这个是第二次个人作业，文件夹下只有一个名为“Bard.py”的python文件，该文件配置正确的cookies后，将能根据指定指令自动从洛谷网网站搜索题目、爬取题目与爬取题解。
  
  - 第一次结队作业
  
    - index.html
  
    - sudoku.py
  
    - 说明：文件夹下有index.html和sudoku.py两个文件。sudoku.py是后端程序代码，应当先运行此程序，再打开index.html。此代码的功能是生成一个完整的数独二维数组，再随机挖空，以此生成数独题目。此程序将允许前端访问**/sudoku**和**/sudoku_more**两个资源url，需要通过Get方法访问这两个网站，随后此程序将返回一个9x9的二维数独数组和九个9x9的二维数独数组。在运行开始时，将会开放本地host的5000端口（协议为http），前端JS脚本通过访问指定网址来获取相应的数据，并根据数据类型生成可填写的表格。
  
    - 可解性保证：在***solve***函数中采用回溯法进行可解性验证
  
      回溯法是一种基于深度优先搜索（DFS）的搜索算法，常用于解决各种组合问题，其中包括数独、八皇后、图的着色等问题。
  
      在数独问题中，回溯法通过递归的方式尝试填充数独格子，如果填充的数字符合数独规则，继续递归下去。如果递归过程中出现了不符合规则的情况，就进行回溯，撤销上一步的操作，尝试其他可能的数字，直到解决问题或者确定无解。
  
      具体步骤如下：
  
      1. **选择决策点：** 选取一个未填写数字的位置作为决策点。
  
      2. **做出选择：** 在当前决策点尝试填入一个数字，例如尝试填入1。
  
      3. **验证选择：** 验证刚刚填入的数字是否符合数独规则，即该数字在当前行、当前列和当前3x3小格子中是否重复。
  
      4. **递归尝试下一个决策点：** 如果当前选择符合规则，就递归地尝试下一个决策点（下一个未填写的位置）。
  
      5. **回溯：** 如果递归过程中遇到无解的情况，或者所有尝试都不符合规则，就进行回溯。回溯是指撤销当前选择，回到上一步，尝试其他可能的数字。
  
      6. **判断终止条件：** 当所有决策点都处理完毕，即数独所有位置都填写了数字（递归终止条件），表示得到了一个可行解。
  
      回溯法不断尝试不同的选择，当找到符合条件的解时，返回解；如果找不到解，就进行回溯，尝试其他选择。这种深度优先的搜索策略保证了解空间的完整性，也就是确保了所有可能的解都能被搜索到。
  
      在数独问题中，回溯法是一种高效的解决方法，因为数独的解空间很大，但回溯法能够在搜索过程中快速排除不符合规则的选择，从而减少搜索的路径。
  
    - 并发实现：
  
      ~~~python
      def generate_sudoku_more():
          global num_sudokus
          with concurrent.futures.ThreadPoolExecutor() as executor:
              sudokus = list(executor.map(lambda _: generate_sudoku(), range(num_sudokus)))
          return sudokus
      ~~~
  
      num_sudokus：生成数组的个数，generate_sudoku()：生成一个数独数组
  
      调用该方法，该方法将生成一个线程池，该方法将并发调用generate_sudoku()方法9次
  
  - index.html
  
    